index <- which(list_of_letter == letter)
return(unlist(list_of_actions[index]))
}
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_final$sequence_id)){
str_i <- get_seqsubset(i)
if (str_i!=""){
list_of_strings <- append(list_of_strings, subset_to_str(str_i))
}
}
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("PTXQC")
source("cleaning.R")
ds_final<-data_2300
#creation d'une liste avec les differentes actions et une liste de meme taille avec des lettres (a la main mdr)
list_of_actions <- unlist(ds_final$actionName)
list_of_actions <- list_of_actions[!duplicated(list_of_actions)]
list_of_letter <- list("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "M", "L", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X")
#fonction qui renvoie une liste des actions de la sequence en parametre
get_seqsubset <- function(seq){
actions_of_seq <- c()
for (l in 1:nrow(ds_final)){
if (ds_final[l, "sequence_id"] == seq){
actions_of_seq <- append(actions_of_seq, ds_final[l, "actionName"])
}
}
return(actions_of_seq)
}
#fonction qui renvoie la chaine de caracteres d'une sequence (on applique action_to_letter a chaque action et apres on concatene la lettre a une str)
subset_to_str <- function(subset){
str <- ""
for (action in subset){
letter <- action_to_letter(action)
str <- paste(str, letter, sep = "")
}
return(str)
}
str_to_subset <- function(str){
letters <- str_to_vec(str)
actions <- c()
i <- 1
for(letter in letters){
actions[i] = letter_to_action(letter)
i <- i+1
}
return(actions)
}
#fonction qui renvoie une lettre a une action
action_to_letter<-function(action){
index <- which(list_of_actions == action)
return(unlist(list_of_letter[index]))
}
letter_to_action<-function(letter){
index <- which(list_of_letter == letter)
return(unlist(list_of_actions[index]))
}
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_final$sequence_id)){
str_i <- get_seqsubset(i)
if (length(str_i)>0){
list_of_strings <- append(list_of_strings, subset_to_str(str_i))
}
}
list_of_strings <- subset(list_of_strings, subset)
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_final$sequence_id)){
str_i <- get_seqsubset(i)
if (length(str_i)>0){
list_of_strings <- append(list_of_strings, subset_to_str(str_i))
}
}
list_of_strings
source("seqToString.R")
source("seqToString.R")
source("utilsClustering.R")
matrix<-stringdistmatrix(list_of_strings, list_of_strings, method = "lcs")
tree<-hclust(as.dist(matrix), method="ward.D")
dend<-as.dendrogram(tree)
par(mar=c(6.1, 4.1, 4.1, 2.1))
plot(tree)
cutree(tree, 5)
source("seqToString.R")
source("utilsClustering.R")
matrix<-stringdistmatrix(list_of_strings, list_of_strings, method = "lcs")
tree<-hclust(as.dist(matrix), method="ward.D")
dend<-as.dendrogram(tree)
par(mar=c(6.1, 4.1, 4.1, 2.1))
plot(tree)
cluster<-cutree(tree, 5)
data_frame(list_of_strings, cluster)
tibble(list_of_strings, cluster)
get_cluster_i<-function(df,i){
return(subset(df, subset= (cluster==i)))
}
find_LCS <- function(vec_str){
return(LCSn(vec_str))
}
get_cluster_i<-function(df,i){
return(subset(df, subset= (cluster==i))$list_of_strings )
}
source("seqToString.R")
source("utilsClustering.R")
matrix<-stringdistmatrix(list_of_strings, list_of_strings, method = "lcs")
tree<-hclust(as.dist(matrix), method="ward.D")
dend<-as.dendrogram(tree)
par(mar=c(6.1, 4.1, 4.1, 2.1))
plot(tree)
cluster<-cutree(tree, 5)
tibble(list_of_strings, cluster)
df<-tibble(list_of_strings, cluster)
get_cluster_i(df, 1)
class(get_cluster_i(df, 1))
source("seqToString.R")
source("utilsClustering.R")
matrix<-stringdistmatrix(list_of_strings, list_of_strings, method = "lcs")
tree<-hclust(as.dist(matrix), method="ward.D")
dend<-as.dendrogram(tree)
par(mar=c(6.1, 4.1, 4.1, 2.1))
plot(tree)
cluster<-cutree(tree, 5)
df<-tibble(list_of_strings, cluster)
get_nodes(df)
#fonction qui merge en fonction du cluster
get_nodes<-function(df){
output<-c()
index <- 1
cluster_subset <- get_cluster_i(df, index)
while (length(cluster_subset)>0){
com_seq<-find_LCS(cluster_subset)
output<-append(output, merge(cluster_subset, com_seq))
}
return(output)
}
get_cluster_i<-function(df,i){
return(subset(df, subset= (cluster==i))$list_of_strings )
}
#fonction qui retourne la partie commune à toutes les chaines de caractère
find_LCS <- function(vec_str){
return(LCSn(vec_str))
}
#fonction qui fusionne N strings à partir de leur séquence commune
merge <- function(vec_str, com_subseq){
splited <- split_string(vec_str, com_subseq)
output<-str_c(splited[1],com_subseq, splited[2])
return(output)
}
#fonction qui retourne la distance entre deux strings et la substring commune la plus longue
distance <- function(string1, string2) {
seqcom <- LCSn(c(string1, string2))
return(c(str_length(seqcom[1]), seqcom))
}
merge_from_subseq <- function(str1, str2, subseq){
pos_str1 = get_pos_subseq(str_to_vec(str1), str_to_vec(subseq))
pos_str2 = get_pos_subseq(str_to_vec(str2), str_to_vec(subseq))
subset_str1<-get_subsets(str1, pos_str1)
subset_str2<-get_subsets(str2, pos_str2)
tmp<-c()
tmp <- StrAlign(c(subset_str1[1], subset_str2[1]), sep="\\r")
for (k in 2:(length(subset_str1))){
tmp=append(tmp,StrAlign(c(subset_str1[k], subset_str2[k]), sep="\\l"))
}
output<-c()
for (k in 1:(length(tmp)/2)){
output=append(output,choose_letters(tmp[2*k-1], tmp[2*k]))
}
output<-str_replace_all(output, " ", "")
output <- paste(output, collapse="")
return(output)
}
get_pos_subseq<- function(str1, subseq){
output_pos = c()
i=1
j=1
while (i<=length(str1) && j<=length(subseq)){
if (str1[i]==subseq[j]){
output_pos[j]=i
j=j+1
}
i=i+1
}
return(output_pos)
}
get_subsets <- function(str1, pos_subseq){
output<-c()
output[1]<-str_sub(str1, end=pos_subseq[1]-1)
for (i in 1:(length(pos_subseq)-1)){
output[i+1]<-str_sub(str1, start=pos_subseq[i], end=pos_subseq[i+1]-1)
}
output[length(pos_subseq)+1]<-str_sub(str1, start=pos_subseq[length(pos_subseq)])
return(output)
}
#fonction qui divise tous les mots en 2 sans prendre la partie commune, et qui les fusionne en 1
split_string<-function(vec_str, com_subseq){
start<-c()
end<-c()
index<-str_locate(vec_str, com_subseq)
for (i in 1:length(vec_str)){
start<-append(start, str_sub(vec_str[i], end=index[i,1]-1))
end<-append(end,str_sub(vec_str[i], start=index[i,2]+1))
}
start<-StrAlign(start, sep="\\r")
end<-StrAlign(end, sep="\\l")
start<-choose_letters(start)
end<-choose_letters(end)
return(c(start, end))
}
#fonction qui forme un mot au hasard à partir des mots entrés
choose_letters<-function(vec_str){
n<-length(vec_str)
k<-str_length(vec_str[1])
res<-sample(x=1:n, size=k, replace=TRUE)
output<-""
for (i in 1:k) {
output<-append(output, str_sub(vec_str[res[i]], start=i, end=i))
}
output<-str_replace_all(output, " ", "")
output <- paste(output, collapse="")
return(output)
}
str_to_vec<-function(str1){
return(unlist(str_split(str1, "")))
}
source("seqToString.R")
source("utilsClustering.R")
matrix<-stringdistmatrix(list_of_strings, list_of_strings, method = "lcs")
tree<-hclust(as.dist(matrix), method="ward.D")
dend<-as.dendrogram(tree)
par(mar=c(6.1, 4.1, 4.1, 2.1))
plot(tree)
cluster<-cutree(tree, 5)
df<-tibble(list_of_strings, cluster)
get_nodes(df)
get_nodes<-function(df){
output<-c()
index <- 1
cluster_subset <- get_cluster_i(df, index)
while (length(cluster_subset)>0){
com_seq<-find_LCS(cluster_subset)
output<-append(output, merge(cluster_subset, com_seq))
index<-index+1
}
return(output)
}
get_nodes(df)
#fonction qui merge en fonction du cluster
get_nodes<-function(df){
output<-c()
index <- 1
cluster_subset <- get_cluster_i(df, index)
while (length(cluster_subset)>0){
print("her")
com_seq<-find_LCS(cluster_subset)
output<-append(output, merge(cluster_subset, com_seq))
index<-index+1
}
return(output)
}
get_nodes(df)
#fonction qui merge en fonction du cluster
get_nodes<-function(df){
output<-c()
index <- 1
cluster_subset <- get_cluster_i(df, index)
while (length(cluster_subset)>0){
print("her")
com_seq<-find_LCS(cluster_subset)
output<-append(output, merge(cluster_subset, com_seq))
index<-index+1
cluster_subset <- get_cluster_i(df, index)
}
return(output)
}
get_nodes(df)
get_nodes(df)
str_to_subset(get_nodes(df)[1])
str_to_subset(get_nodes(df)[1])
str_to_subset(get_nodes(df)[1])
#fonction qui merge en fonction du cluster
get_nodes<-function(df){
output<-c()
index <- 1
cluster_subset <- get_cluster_i(df, index)
while (length(cluster_subset)>0){
com_seq<-find_LCS(cluster_subset)
output<-append(output, merge(cluster_subset, com_seq))
index<-index+1
cluster_subset <- get_cluster_i(df, index)
}
return(output)
}
vect<-(1:10)
vect
str_to_subset(get_nodes(df)[1])
df
str_to_subset(get_nodes(df)[1])
get_nodes(df)[1]
get_nodes(df)
df<-tibble(list_of_strings, cluster)
nodes<-get_nodes(df)
seq1<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
seq1
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
for (i in 2:5){
ds_clustered<-rbind(ds_clustered, tibble(str_to_subset(nodes[i]), rep(1,length(nodes[i]))))
}
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
for (i in 2:5){
X<-tibble(str_to_subset(nodes[i]), rep(1,length(nodes[i])))
ds_clustered<-rbind(ds_clustered, X)
}
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
for (i in 2:5){
X<-tibble(str_to_subset(nodes[i]), rep(1,length(nodes[i])))
print(X)
ds_clustered<-rbind(ds_clustered, X)
}
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
colnames(ds_clustered)<-c("actionName", "sequence")
for (i in 2:5){
X<-tibble(str_to_subset(nodes[i]), rep(1,length(nodes[i])))
colnames(X)<-c("actionName", "sequence")
print(X)
ds_clustered<-rbind(ds_clustered, X)
}
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
colnames(ds_clustered)<-c("actionName", "sequence")
for (i in 2:5){
X<-tibble(str_to_subset(nodes[i]), rep(1,length(nodes[i])))
colnames(X)<-c("actionName", "sequence")
ds_clustered<-rbind(ds_clustered, X)
}
View(ds_clustered)
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
colnames(ds_clustered)<-c("actionName", "sequence")
for (i in 2:5){
X<-tibble(str_to_subset(nodes[i]), rep(i,length(nodes[i])))
colnames(X)<-c("actionName", "sequence")
ds_clustered<-rbind(ds_clustered, X)
}
View(ds_clustered)
#création de faux timestamp
start <- as.POSIXct(c(1:length(ds_clustered)), origin = "1970-01-01", tz = "UTC")
start
#création de faux timestamp
start <- as.POSIXct(c(1:length(ds_clustered[1])), origin = "1970-01-01", tz = "UTC")
start
#création de faux timestamp
start <- as.POSIXct(c(1:length(ds_clustered[1,])), origin = "1970-01-01", tz = "UTC")
start
#création de faux timestamp
start <- as.POSIXct(c(1:length(ds_clustered[,1])), origin = "1970-01-01", tz = "UTC")
start
ds_clustered
#création de faux timestamp
start <- as.POSIXct(c(1:length(ds_clustered$actionName)), origin = "1970-01-01", tz = "UTC")
start
complete<-start
ds_clust_format <- dataframe(start, complete, ds_clustered)
ds_clust_format <- merge(tibble(start, complete), ds_clustered)
ds_clust_format <- merge(tibble(start, complete), ds_clustered)
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("stringdist")
library("DescTools")
library("PTXQC")
#fonction qui merge en fonction du cluster
get_nodes<-function(df){
output<-c()
index <- 1
cluster_subset <- get_cluster_i(df, index)
while (length(cluster_subset)>0){
com_seq<-find_LCS(cluster_subset)
output<-append(output, merge_strings(cluster_subset, com_seq))
index<-index+1
cluster_subset <- get_cluster_i(df, index)
}
return(output)
}
get_cluster_i<-function(df,i){
return(subset(df, subset= (cluster==i))$list_of_strings )
}
#fonction qui retourne la partie commune à toutes les chaines de caractère
find_LCS <- function(vec_str){
return(LCSn(vec_str))
}
#fonction qui fusionne N strings à partir de leur séquence commune
merge_strings <- function(vec_str, com_subseq){
splited <- split_string(vec_str, com_subseq)
output<-str_c(splited[1],com_subseq, splited[2])
return(output)
}
#fonction qui retourne la distance entre deux strings et la substring commune la plus longue
distance <- function(string1, string2) {
seqcom <- LCSn(c(string1, string2))
return(c(str_length(seqcom[1]), seqcom))
}
merge_from_subseq <- function(str1, str2, subseq){
pos_str1 = get_pos_subseq(str_to_vec(str1), str_to_vec(subseq))
pos_str2 = get_pos_subseq(str_to_vec(str2), str_to_vec(subseq))
subset_str1<-get_subsets(str1, pos_str1)
subset_str2<-get_subsets(str2, pos_str2)
tmp<-c()
tmp <- StrAlign(c(subset_str1[1], subset_str2[1]), sep="\\r")
for (k in 2:(length(subset_str1))){
tmp=append(tmp,StrAlign(c(subset_str1[k], subset_str2[k]), sep="\\l"))
}
output<-c()
for (k in 1:(length(tmp)/2)){
output=append(output,choose_letters(tmp[2*k-1], tmp[2*k]))
}
output<-str_replace_all(output, " ", "")
output <- paste(output, collapse="")
return(output)
}
get_pos_subseq<- function(str1, subseq){
output_pos = c()
i=1
j=1
while (i<=length(str1) && j<=length(subseq)){
if (str1[i]==subseq[j]){
output_pos[j]=i
j=j+1
}
i=i+1
}
return(output_pos)
}
get_subsets <- function(str1, pos_subseq){
output<-c()
output[1]<-str_sub(str1, end=pos_subseq[1]-1)
for (i in 1:(length(pos_subseq)-1)){
output[i+1]<-str_sub(str1, start=pos_subseq[i], end=pos_subseq[i+1]-1)
}
output[length(pos_subseq)+1]<-str_sub(str1, start=pos_subseq[length(pos_subseq)])
return(output)
}
#fonction qui divise tous les mots en 2 sans prendre la partie commune, et qui les fusionne en 1
split_string<-function(vec_str, com_subseq){
start<-c()
end<-c()
index<-str_locate(vec_str, com_subseq)
for (i in 1:length(vec_str)){
start<-append(start, str_sub(vec_str[i], end=index[i,1]-1))
end<-append(end,str_sub(vec_str[i], start=index[i,2]+1))
}
start<-StrAlign(start, sep="\\r")
end<-StrAlign(end, sep="\\l")
start<-choose_letters(start)
end<-choose_letters(end)
return(c(start, end))
}
#fonction qui forme un mot au hasard à partir des mots entrés
choose_letters<-function(vec_str){
n<-length(vec_str)
k<-str_length(vec_str[1])
res<-sample(x=1:n, size=k, replace=TRUE)
output<-""
for (i in 1:k) {
output<-append(output, str_sub(vec_str[res[i]], start=i, end=i))
}
output<-str_replace_all(output, " ", "")
output <- paste(output, collapse="")
return(output)
}
str_to_vec<-function(str1){
return(unlist(str_split(str1, "")))
}
#on va adapter les datas des clusters
#création de faux timestamp
start <- as.POSIXct(c(1:length(ds_clustered$actionName)), origin = "1970-01-01", tz = "UTC")
complete<-start
ds_clust_format <- merge(tibble(start, complete), ds_clustered)
merge
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("stringdist")
library("DescTools")
library("PTXQC")
source("seqToString.R")
source("utilsClustering.R")
matrix<-stringdistmatrix(list_of_strings, list_of_strings, method = "lcs")
tree<-hclust(as.dist(matrix), method="ward.D")
dend<-as.dendrogram(tree)
par(mar=c(6.1, 4.1, 4.1, 2.1))
plot(tree)
cluster<-cutree(tree, 5)
df<-tibble(list_of_strings, cluster)
nodes<-get_nodes(df)
ds_clustered<-tibble(str_to_subset(nodes[1]), rep(1,length(nodes[1])))
colnames(ds_clustered)<-c("actionName", "sequence")
for (i in 2:5){
X<-tibble(str_to_subset(nodes[i]), rep(i,length(nodes[i])))
colnames(X)<-c("actionName", "sequence")
ds_clustered<-rbind(ds_clustered, X)
}
merge
