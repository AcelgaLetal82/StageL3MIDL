library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("PTXQC")
source("cleaning.R")
ds_studied<-data_2300_restricted
source("cleaning.R")
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
setwd("c:\\Users\\malat\\OneDrive\\Bureau\\S6\\Stage\\StageL3MIDL")
ds <- read.csv(".\\data_rugby.csv", sep=";", dec=".")
DATE_MATCH = "29-04-2023"
#on filtre les donées pour garder uniquement les colonnes "utiles"
ds_final = data.frame(ds["team_id"], ds["ps_timestamp"],ds["ps_endstamp"], ds["action"], ds["actionName"],ds["x_coord"], ds["y_coord"], ds["sequence_id"])
unused_actions = list("Ref Review", "Sub In", "Sub Out", "Sequence", "", "Playmaker Options", "Period", " ", "Collection")
ds_final <- subset(ds_final, subset = !(actionName %in% unused_actions ))
#conversion des timestamp en type POSIXct
secondes_avec_ms <-  as.numeric(ds_final$ps_timestamp)
date_posix <- as.POSIXct(secondes_avec_ms, origin = "1970-01-01", tz = "UTC")
ds_final$date_posix_start <- date_posix
secondes_avec_ms <-  as.numeric(ds_final$ps_endstamp)
date_posix <- as.POSIXct(secondes_avec_ms, origin = "1970-01-01", tz = "UTC")
ds_final$date_posix_end <- date_posix
#ajout colonne position sur le terrain
{
ds_final$zoneAction <- rep(1, nrow(ds_final))
set_zone <- function(equipe){
if (equipe == 2300){
return(0)
}
if (equipe == 2350){
return(2)
}
}
l<-1
while (l<nrow(ds_final)){
if (ds_final[l,"actionName"]=="Opposition 22 Entry"){
debut <- ds_final[l, "date_posix_start"]
fin <- ds_final[l, "date_posix_end"]
equipe <- ds_final[l, "team_id"]
while (ds_final[l, "date_posix_end"]<=fin){
ds_final[l, "zoneAction"]<- set_zone(equipe)
l <- l+1
}
} else{
l <- l+1
}
}
}
#séquençage
{
n_sequence = 1
l<-1
while (l %in% 1:nrow(ds_final)){
ds_final[l,"sequence_id"] = n_sequence
if (ds_final[l,"actionName"] == "Possession"){
temps_fin <- ds_final[l,"ps_endstamp"]
l<-l+1
while (ds_final[l, "ps_endstamp"]<=temps_fin){
ds_final[l,"sequence_id"] = n_sequence
l<-l+1
}
if (ds_final[l, "actionName"]=="Goal Kick"){
ds_final[l,"sequence_id"] = n_sequence
}else{
ds_final[l,"sequence_id"] = n_sequence+1
}
n_sequence <- n_sequence +1
}
l<-l+1
}
}
#on catégorise chaque action selon 3 catégories: O (Offensif), D (Defensif), N (Neutre)
#on rentre les premières actions à la main
{categories = c("O", "D", "O", "N", "D", "O", "N", "N", "O", "O", "O", "D", "N")
categories[14]<- "N"
categories[21]<-"N"
categories[23]<-"D"
categories[24]<-"D"
categories[27]<-"O"
categories[40]<-"D"
categories[43]<-"N"
categories[44]<-"O"
categories[45]<-"D"
categories[46]<-"O"
l<-1
for (l in 1:nrow(ds_final)){
ds_final[l, "actionName"] <-  paste0(categories[ds_final[l, "action"]],"-",ds_final[l, "actionName"])
}
}
#on sépare les séquences des deux équipes
liste_sequences_2300 <- c()
liste_sequences_2350 <- c()
i <- 1
j <- 1
for (l in 1:nrow(ds_final)){
if (ds_final[l, "action"] == 15 & ds_final[l, "team_id"] == 2300){
liste_sequences_2300[i] <- ds_final[l, "sequence_id"]
i <- i + 1
} else {
liste_sequences_2350[j] <- ds_final[l, "sequence_id"]
j <- j + 1
}
}
#informations que l'on va utiliser pour la suite
data_2300 = distinct(subset(ds_final, subset = (sequence_id %in% liste_sequences_2300)))
data_2350 = distinct(subset(ds_final, subset = (sequence_id %in% liste_sequences_2350)))
#on supprime les actions "Possession" qui ne servent plus
data_2300 = subset (data_2300, subset = (action != 15))
data_2350 = subset (data_2350, subset = (action != 15))
#Isolation des séquences souhaitées
data_2300_restricted <- subset(data_2300, subset=(sequence_id %in% 12:26))
data_2350_restricted <- subset(data_2350, subset=(sequence_id %in% 12:26))
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("PTXQC")
source("cleaning.R")
ds_studied<-data_2300_restricted
#creation d'une liste avec les differentes actions et une liste de meme taille avec des lettres (a la main mdr)
list_of_actions <- unlist(ds_studied$actionName)
list_of_actions <- list_of_actions[!duplicated(list_of_actions)]
list_of_letter <- list("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "M", "L", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X")
#fonction qui renvoie une liste des actions de la sequence en parametre
seqID_to_actions <- function(seq_id){
return(subset(ds_studied, subset(sequence_id==seq_id)))
}
#fonction qui renvoie un vecteur avec les identifiants des sequences contenue dans la liste
get_all_id_seq <- function(list_seq){
return (as.vector(unique(list_seq$sequence_id)))
}
#fonction qui renvoie la chaine de caracteres d'une sequence (on applique action_to_letter a chaque action et apres on concatene la lettre a une str)
actions_to_str <- function(subset){
str <- ""
for (action in subset){
letter <- action_to_letter(action)
str <- paste(str, letter, sep = "")
}
return(str)
}
str_to_actions <- function(str){
letters <- str_to_vec(str)
actions <- c()
i <- 1
for(letter in letters){
actions[i] = letter_to_action(letter)
i <- i+1
}
return(actions)
}
#fonction qui renvoie une lettre a une action
action_to_letter<-function(action){
index <- which(list_of_actions == action)
return(unlist(list_of_letter[index]))
}
letter_to_action<-function(letter){
index <- which(list_of_letter == letter)
return(unlist(list_of_actions[index]))
}
#donne l'id de la sequence associée
find_seqId<- function(str) {
valeurs<-get_all_id_seq(ds_studied)
for (i in valeurs) {
if (str == list_of_strings[i]) {
return(i)
}
}
return (-1)
}
str_to_seq <- function(str) {
id <- find_seqId(str)
seq <- subset(ds_final, subset = (sequence_id==id))
return(seq)
}
#-----------------------------MAIN-----------------------------#
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_studied$sequence_id)){
str_i <- seqID_to_actions(i)
if (length(str_i)>0){
list_of_strings[i] <-subset_to_str(str_i)
}
}
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("PTXQC")
source("cleaning.R")
ds_studied<-data_2300_restricted
#creation d'une liste avec les differentes actions et une liste de meme taille avec des lettres (a la main mdr)
list_of_actions <- unlist(ds_studied$actionName)
list_of_actions <- list_of_actions[!duplicated(list_of_actions)]
list_of_letter <- list("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "M", "L", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X")
#fonction qui renvoie une liste des actions de la sequence en parametre
seqID_to_actions <- function(seq_id){
return(subset(ds_studied, subset=(sequence_id==seq_id)))
}
#fonction qui renvoie un vecteur avec les identifiants des sequences contenue dans la liste
get_all_id_seq <- function(list_seq){
return (as.vector(unique(list_seq$sequence_id)))
}
#fonction qui renvoie la chaine de caracteres d'une sequence (on applique action_to_letter a chaque action et apres on concatene la lettre a une str)
actions_to_str <- function(subset){
str <- ""
for (action in subset){
letter <- action_to_letter(action)
str <- paste(str, letter, sep = "")
}
return(str)
}
str_to_actions <- function(str){
letters <- str_to_vec(str)
actions <- c()
i <- 1
for(letter in letters){
actions[i] = letter_to_action(letter)
i <- i+1
}
return(actions)
}
#fonction qui renvoie une lettre a une action
action_to_letter<-function(action){
index <- which(list_of_actions == action)
return(unlist(list_of_letter[index]))
}
letter_to_action<-function(letter){
index <- which(list_of_letter == letter)
return(unlist(list_of_actions[index]))
}
#donne l'id de la sequence associée
find_seqId<- function(str) {
valeurs<-get_all_id_seq(ds_studied)
for (i in valeurs) {
if (str == list_of_strings[i]) {
return(i)
}
}
return (-1)
}
str_to_seq <- function(str) {
id <- find_seqId(str)
seq <- subset(ds_final, subset = (sequence_id==id))
return(seq)
}
#-----------------------------MAIN-----------------------------#
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_studied$sequence_id)){
str_i <- seqID_to_actions(i)
if (length(str_i)>0){
list_of_strings[i] <-subset_to_str(str_i)
}
}
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_studied$sequence_id)){
str_i <- seqID_to_actions(i)
if (length(str_i)>0){
list_of_strings[i] <-seqID_to_actions(str_i)
}
}
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("PTXQC")
source("cleaning.R")
ds_studied<-data_2300_restricted
#creation d'une liste avec les differentes actions et une liste de meme taille avec des lettres (a la main mdr)
list_of_actions <- unlist(ds_studied$actionName)
list_of_actions <- list_of_actions[!duplicated(list_of_actions)]
list_of_letter <- list("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "M", "L", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X")
#fonction qui renvoie une liste des actions de la sequence en parametre
seqID_to_actions <- function(seq_id){
return(subset(ds_studied, subset=(sequence_id==seq_id)))
}
#fonction qui renvoie un vecteur avec les identifiants des sequences contenue dans la liste
get_all_id_seq <- function(list_seq){
return (as.vector(unique(list_seq$sequence_id)))
}
#fonction qui renvoie la chaine de caracteres d'une sequence (on applique action_to_letter a chaque action et apres on concatene la lettre a une str)
actions_to_str <- function(subset){
str <- ""
for (action in subset){
letter <- action_to_letter(action)
str <- paste(str, letter, sep = "")
}
return(str)
}
str_to_actions <- function(str){
letters <- str_to_vec(str)
actions <- c()
i <- 1
for(letter in letters){
actions[i] = letter_to_action(letter)
i <- i+1
}
return(actions)
}
#fonction qui renvoie une lettre a une action
action_to_letter<-function(action){
index <- which(list_of_actions == action)
return(unlist(list_of_letter[index]))
}
letter_to_action<-function(letter){
index <- which(list_of_letter == letter)
return(unlist(list_of_actions[index]))
}
#donne l'id de la sequence associée
find_seqId<- function(str) {
valeurs<-get_all_id_seq(ds_studied)
for (i in valeurs) {
if (str == list_of_strings[i]) {
return(i)
}
}
return (-1)
}
str_to_seq <- function(str) {
id <- find_seqId(str)
seq <- subset(ds_final, subset = (sequence_id==id))
return(seq)
}
#-----------------------------MAIN-----------------------------#
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_studied$sequence_id)){
str_i <- seqID_to_actions(i)
if (length(str_i)>0){
list_of_strings[i] <-seqID_to_actions(str_i)
}
}
list_of_strings <- c()
for (i in 1:max(ds_studied$sequence_id)){
print(i)
str_i <- seqID_to_actions(i)
if (length(str_i)>0){
list_of_strings[i] <-seqID_to_actions(str_i)
}
}
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
for (i in 1:max(ds_studied$sequence_id)){
print(i)
str_i <- seqID_to_actions(i)
print(str_i)
if (length(str_i)>0){
list_of_strings[i] <-seqID_to_actions(str_i)
}
}
View(data_2300)
library("tidyverse")
library("ggplot2")
library("dplyr")
library("bupaverse")
library("lubridate")
library("stringr")
library("PTXQC")
source("cleaning.R")
ds_studied<-data_2300_restricted
#creation d'une liste avec les differentes actions et une liste de meme taille avec des lettres (a la main mdr)
list_of_actions <- unlist(ds_studied$actionName)
list_of_actions <- list_of_actions[!duplicated(list_of_actions)]
list_of_letter <- list("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "M", "L", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X")
#fonction qui renvoie une liste des actions de la sequence en parametre
seqID_to_actions <- function(seq_id){
return(subset(ds_studied, subset=(sequence_id==seq_id)))
}
#fonction qui renvoie un vecteur avec les identifiants des sequences contenue dans la liste
get_all_id_seq <- function(list_seq){
return (as.vector(unique(list_seq$sequence_id)))
}
#fonction qui renvoie la chaine de caracteres d'une sequence (on applique action_to_letter a chaque action et apres on concatene la lettre a une str)
actions_to_str <- function(subset){
str <- ""
for (action in subset){
letter <- action_to_letter(action)
str <- paste(str, letter, sep = "")
}
return(str)
}
str_to_actions <- function(str){
letters <- str_to_vec(str)
actions <- c()
i <- 1
for(letter in letters){
actions[i] = letter_to_action(letter)
i <- i+1
}
return(actions)
}
#fonction qui renvoie une lettre a une action
action_to_letter<-function(action){
index <- which(list_of_actions == action)
return(unlist(list_of_letter[index]))
}
letter_to_action<-function(letter){
index <- which(list_of_letter == letter)
return(unlist(list_of_actions[index]))
}
#donne l'id de la sequence associée
find_seqId<- function(str) {
ids<-get_all_id_seq(ds_studied)
for (i in ids) {
if (str == list_of_strings[i]) {
return(i)
}
}
return (-1)
}
str_to_seq <- function(str) {
id <- find_seqId(str)
seq <- subset(ds_final, subset = (sequence_id==id))
return(seq)
}
#-----------------------------MAIN-----------------------------#
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
ids<-get_all_id_seq(ds_studied)
for (i in ids){
print(i)
str_i <- seqID_to_actions(i)
print(str_i)
if (length(str_i)>0){
list_of_strings[i] <-seqID_to_actions(str_i)
}
}
#ZONE TEST
print(list_of_strings)
all_seq<-get_all_id_seq(ds_studied)
print(str_to_seq("NDEFGGGGGGMO"))
#on cree la liste contenant les sequences sous forme de chaine de caracteres
list_of_strings <- c()
ids<-get_all_id_seq(ds_studied)
for (i in ids){
list_of_strings <- append(list_of_strings, actions_to_str(seqID_to_actions(i)))
}
